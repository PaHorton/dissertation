""".. py:module:: pdfcheck.core

Classes for parsing and getting attributes of PDFs"""

from functools import cached_property
import re
from statistics import mean, stdev
from typing import List, Tuple, Type

import attr
import fitz

import pprint


@attr.s
class BoundingBox(object):
    """
    A bounding box with four values: left, up, right, down
    """

    left = attr.ib(
        validator=attr.validators.instance_of(float),
        converter=float,
    )
    upper = attr.ib(
        validator=attr.validators.instance_of(float),
        converter=float,
    )
    right = attr.ib(
        validator=attr.validators.instance_of(float),
        converter=float,
    )
    lower = attr.ib(
        validator=attr.validators.instance_of(float),
        converter=float,
    )

    @classmethod
    def from_rect(cls, rect):
        # `rect` is a `fitz.Rect`
        return cls(*list(rect))


@attr.s
class TextBlock(object):
    """
    Text blocks generated by :func:`fitz.TextPage.extractBLOCKS()`
    are just tuples. This class provides an object-oriented interface
    to the data.

    Note these can be image blocks, too, even though the class is
    called "TextBlock".
    """

    left = attr.ib(
        validator=attr.validators.instance_of(float),
        converter=float,
    )
    upper = attr.ib(
        validator=attr.validators.instance_of(float),
        converter=float,
    )
    right = attr.ib(
        validator=attr.validators.instance_of(float),
        converter=float,
    )
    lower = attr.ib(
        validator=attr.validators.instance_of(float),
        converter=float,
    )
    text = attr.ib(
        validator=attr.validators.instance_of(str),
    )
    index = attr.ib(
        validator=attr.validators.instance_of(int),
    )
    type = attr.ib(
        validator=attr.validators.instance_of(str),
        converter=lambda x: "text" if (x == 0) else "image",
    )

    @classmethod
    def from_block(cls, data):
        # `data` is a is a 7-element tuple
        # returned by `fitz.TextPage.extractBLOCKS()`
        return cls(*data)

    def one_line(self) -> str:
        """
        Convert text to one line with no line returns in the text
        """
        return self.text.rstrip().replace("\n", " ")

    @cached_property
    def horizontal_center(self) -> float:
        """The horizontal center of the block in points"""
        return (self.left + self.right) / 2


@attr.s
class TextBlockCollection(object):
    """
    A collection of :py:class:`TextBlock` objects
    """

    text_blocks = attr.ib(
        validator=attr.validators.instance_of(List),
    )

    def one_line(self) -> str:
        """
        Returns the text of any text blocks as a single string
        """
        return " ".join(map(lambda x: x.one_line(), self.text_blocks))

    def horizontal_center(self) -> dict:
        """
        Returns the average, min, max, and standard deviation of
        the horizontal centers of the text blocks in this collection
        """
        centers = list(map(lambda x: x.horizontal_center, self.text_blocks))

        return {
            "mean": mean(centers),
            "min": min(centers),
            "max": max(centers),
            "stdev": stdev(centers),
        }

    def vertical_space(self) -> list:
        """
        Returns a list with the distance between text blocks
        """
        result = list()

        last = self.text_blocks[0]
        result.append(last.lower - last.upper)
        for text_block in self.text_blocks[1:]:
            result.append(text_block.upper - last.lower)
            result.append(text_block.lower - text_block.upper)
            last = text_block

        return result


@attr.s
class Page(object):
    """
    A class for checking attributes of a PDF page
    """

    page = attr.ib()
    """Typically a :py:class:`fitz.Page`"""

    @cached_property
    def bounding_box(self) -> Type[BoundingBox]:
        """A :py:class:`BoundingBox` for the boundaries of the page"""

        # the media box is the whole page (including crop marks, slugs, etc.)
        # if the page were printed; the media box contains the bleed box and
        # marks outside the bleed box

        # the bleed box contains the trim box plus any bleed marks

        # the trim box defines the dimensions of a finished page (after trimming);
        # PyMuPDF does not have a trim box method, but the crop box is typically
        # the same as the trim box, so use that

        # the crop box is the part of the page that displays in a PDF viewer;
        # used for proofing the page

        # this approach does not account for the possibility of rotated pages:
        return BoundingBox.from_rect(self.page.CropBox)

    @cached_property
    def text_block_collection(self) -> Type[TextBlockCollection]:
        """A :py:class:`TextBlockCollection` for text blocks on the page"""
        return TextBlockCollection(
            text_blocks=list(
                map(
                    lambda x: TextBlock.from_block(x),
                    self.page.getTextPage().extractBLOCKS(),
                )
            )
        )

    @cached_property
    def text_spans(self) -> List:
        """
        A list of the "spans" on the page
        (see `fitz.TextPage.extractDICT()`)
        """
        spans = list()

        # https://pymupdf.readthedocs.io/en/latest/textpage.html#dictionary-structure-of-extractdict-and-extractrawdict
        details = self.page.getTextPage().extractDICT()
        for block in details["blocks"]:
            # skip image blocks
            if block["type"] == 1:
                continue

            for line in block["lines"]:
                spans.extend(line["spans"])

        return spans

    def is_horizontally_centered(self) -> bool:
        """
        Returns Boolean indicating whether content is
        horizontally centered on the page
        """
        page_center = (self.bounding_box.left + self.bounding_box.right) / 2

        content_center = self.text_block_collection.horizontal_center()

        tolerance = 1
        if page_center - tolerance < content_center["min"]:
            if page_center + tolerance > content_center["max"]:
                return True

        return False

    def vertical_space(self) -> list:
        """
        Returns a list with the distance between text blocks
        """
        return self.text_block_collection.vertical_space()
